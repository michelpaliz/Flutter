Short answer: they’re **not** doing the same thing.

* **`EventDisplayManager`** = the **renderer**.
  It knows how to build the different event widgets (details card, compact strip, timeline strip, schedule card, async future content). It optionally holds an `EventActionManager` and always needs an `EventContentBuilder` (mainly for colors/content bits). It directly returns Widgets.

* **`EventUIManager`** = a thin **facade/wrapper**.
  It bundles four things (`ColorManager`, `EventContentBuilder`, `EventActionManager`, `EventDisplayManager`) and **delegates** all UI building to `EventDisplayManager`, plus exposes the **add-event button** from `EventActionManager`. It doesn’t render anything itself—just forwards calls.

So, `EventUIManager` is convenience sugar; `EventDisplayManager` is the actual worker.

## Should you keep both?

* If you want a single injection point for screens (one object to pass around), keep **`EventUIManager`** as a facade and keep **all rendering** in `EventDisplayManager`.
* If you prefer fewer layers, you can **drop `EventUIManager`** and call `EventDisplayManager` + `EventActionManager` directly.

## Minimal cleanup ideas

* Make `EventDisplayManager` **stateless** (no stored `_actionManager`; pass it as a param) to avoid hidden state.
* Rename for clarity:

  * `EventDisplayManager` → `EventViewFactory` (pure builders)
  * `EventUIManager` → `EventUIFacade` (composition + delegation)
* Keep “button-building” only in `EventActionManager` (already true).
* Remove duplicate imports and unused fields (e.g., if `EventUIManager.contentBuilder` isn’t used outside constructor, drop the field).

## Example: stateless display + simple facade

```dart
class EventViewFactory {
  final EventContentBuilder content;
  EventViewFactory(this.content);

  Widget details({... , required EventActionManager actions}) => EventDetailsCard(..., actionManager: actions, colorManager: content.colorManager);
  Widget futureContent({... , required EventActionManager actions}) => EventFutureContentWidget(..., actionManager: actions, colorManager: content.colorManager);
  Widget nonMonth({... , required EventActionManager actions}) => EventCompactView(..., actionManager: actions, colorManager: content.colorManager);
  Widget timeline({... , required EventActionManager actions}) => TimelineStripWidget(..., actionManager: actions, colorManager: content.colorManager);
  Widget schedule({... , required EventActionManager actions}) => ScheduleCardView(..., actionManager: actions, cardColor: content.colorManager.getColor(event.eventColorIndex));
}

class EventUIFacade {
  final EventActionManager actions;
  final EventViewFactory views;
  EventUIFacade({required this.actions, required this.views});

  // delegate
  Widget details(...) => views.details(..., actions: actions);
  Widget futureContent(...) => views.futureContent(..., actions: actions);
  Widget nonMonth(...) => views.nonMonth(..., actions: actions);
  Widget timeline(...) => views.timeline(..., actions: actions);
  Widget schedule(...) => views.schedule(..., actions: actions);

  // from actions
  Widget addButton(BuildContext ctx, Group group) => actions.buildAddEventButton(ctx, group);
}
```

This keeps responsibilities crisp:

* **Factory** builds widgets.
* **Actions** builds action widgets/handlers.
* **Facade** wires them together for callers.

If you want, I can refactor your current files into this shape with exact method signatures you already use.
