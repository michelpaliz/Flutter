import 'package:hexora/a-models/group_model/calendar/calendar.dart';
import 'package:hexora/a-models/notification_model/userInvitation_status.dart';

class Group {
  // ---------- Core ----------
  final String id;
  String name;
  final String ownerId;

  /// userRoles is keyed by **userId**, not username.
  /// Values are one of: "owner", "admin", "co-admin", "member"
  final Map<String, String> userRoles;

  List<String> userIds;
  DateTime createdTime;
  String description;

  // ---------- Media ----------
  String? photoUrl; // CDN/public URL if AVATARS_PUBLIC
  String? photoBlobName; // e.g. "groups/<id>/<uuid>.jpg"
  String? computedPhotoUrl; // generated by backend virtual

  // ---------- Invites ----------
  /// invitedUsers: Map<userId, UserInviteStatus>
  Map<String, UserInviteStatus>? invitedUsers;

  // ---------- Calendar ----------
  String? defaultCalendarId; // set by backend
  Calendar? defaultCalendar; // optional snapshot (GET /groups/:id)

  Group({
    required this.id,
    required this.name,
    required this.ownerId,
    required this.userRoles,
    required this.userIds,
    required this.createdTime,
    required this.description,
    this.photoUrl,
    this.photoBlobName,
    this.computedPhotoUrl,
    this.invitedUsers,
    this.defaultCalendarId,
    this.defaultCalendar,
  });

  // ---------- JSON ----------
  factory Group.fromJson(Map<String, dynamic> json) {
    final userIds = (json['userIds'] as List<dynamic>?)
            ?.map((e) => e.toString())
            .toList() ??
        <String>[];

    // invitedUsers: userId -> UserInviteStatus
    final invitedUsersJson =
        (json['invitedUsers'] as Map<String, dynamic>?) ?? <String, dynamic>{};
    final invitedUsers = invitedUsersJson.map(
      (k, v) => MapEntry(k, UserInviteStatus.fromJson(v)),
    );

    // optional defaultCalendar
    Calendar? defaultCal;
    if (json['defaultCalendar'] is Map<String, dynamic>) {
      defaultCal = Calendar.fromJson(json['defaultCalendar']);
    }

    return Group(
      id: (json['id'] ?? json['_id'] ?? '').toString(),
      name: (json['name'] ?? '').toString(),
      ownerId: (json['ownerId'] ?? '').toString(),
      userRoles: Map<String, String>.from(json['userRoles'] ?? {}),
      userIds: userIds,
      createdTime: json['createdTime'] != null
          ? DateTime.parse(json['createdTime'].toString())
          : DateTime.now(),
      description: (json['description'] ?? '').toString(),
      photoUrl: json['photoUrl']?.toString(),
      photoBlobName: json['photoBlobName']?.toString(),
      computedPhotoUrl: json['computedPhotoUrl']?.toString(),
      invitedUsers: invitedUsers,
      defaultCalendarId: json['defaultCalendarId']?.toString(),
      defaultCalendar: defaultCal,
    );
  }

  /// For group updates (matches backend whitelist)
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'description': description,
      if (photoUrl != null) 'photoUrl': photoUrl,
      if (photoBlobName != null) 'photoBlobName': photoBlobName,
      'userRoles': userRoles, // userId -> role
      'userIds': userIds,
      if (invitedUsers != null)
        'invitedUsers': invitedUsers!.map((k, v) => MapEntry(k, v.toJson())),
    };
  }

  /// For group creation (backend assigns calendar)
  Map<String, dynamic> toJsonForCreation() {
    return {
      'name': name,
      'ownerId': ownerId,
      'userRoles': userRoles, // userId -> role
      'userIds': userIds,
      'description': description,
      'createdTime': createdTime.toIso8601String(),
      if (photoUrl != null) 'photoUrl': photoUrl,
      if (photoBlobName != null) 'photoBlobName': photoBlobName,
      if (invitedUsers != null)
        'invitedUsers': invitedUsers!.map((k, v) => MapEntry(k, v.toJson())),
    };
  }

  // ---------- Copy ----------
  Group copyWith({
    String? id,
    String? name,
    String? ownerId,
    Map<String, String>? userRoles,
    List<String>? userIds,
    DateTime? createdTime,
    String? description,
    String? photoUrl,
    String? photoBlobName,
    String? computedPhotoUrl,
    Map<String, UserInviteStatus>? invitedUsers,
    String? defaultCalendarId,
    Calendar? defaultCalendar,
  }) {
    return Group(
      id: id ?? this.id,
      name: name ?? this.name,
      ownerId: ownerId ?? this.ownerId,
      userRoles: userRoles ?? Map<String, String>.from(this.userRoles),
      userIds: userIds ?? List<String>.from(this.userIds),
      createdTime: createdTime ?? this.createdTime,
      description: description ?? this.description,
      photoUrl: photoUrl ?? this.photoUrl,
      photoBlobName: photoBlobName ?? this.photoBlobName,
      computedPhotoUrl: computedPhotoUrl ?? this.computedPhotoUrl,
      invitedUsers: invitedUsers ?? this.invitedUsers,
      defaultCalendarId: defaultCalendarId ?? this.defaultCalendarId,
      defaultCalendar: defaultCalendar ?? this.defaultCalendar,
    );
  }

  // ---------- Helpers ----------
  bool isOwner(String userId) => ownerId == userId;

  /// Returns the normalized role for this user.
  String roleFor(String userId) {
    if (isOwner(userId)) return 'owner';
    final r = userRoles[userId];
    const valid = {'owner', 'admin', 'co-admin', 'member'};
    return valid.contains(r) ? r! : 'member';
  }

  List<String> get adminIds => userRoles.entries
      .where((e) => e.value == 'admin')
      .map((e) => e.key)
      .toList();

  List<String> get coAdminIds => userRoles.entries
      .where((e) => e.value == 'co-admin')
      .map((e) => e.key)
      .toList();

  List<String> get memberIds => userRoles.entries
      .where((e) => e.value == 'member')
      .map((e) => e.key)
      .toList();

  /// Primary way to get the calendar id
  String? get calendarId =>
      (defaultCalendarId != null && defaultCalendarId!.isNotEmpty)
          ? defaultCalendarId
          : defaultCalendar?.id;

  bool get hasCalendar => calendarId != null;

  // ---------- Equality ----------
  bool isEqual(Group other) {
    return id == other.id &&
        name == other.name &&
        ownerId == other.ownerId &&
        userRoles.toString() == other.userRoles.toString() &&
        _listEq(userIds, other.userIds) &&
        description == other.description &&
        photoUrl == other.photoUrl &&
        photoBlobName == other.photoBlobName &&
        computedPhotoUrl == other.computedPhotoUrl &&
        defaultCalendarId == other.defaultCalendarId;
  }

  static bool _listEq(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  // ---------- Defaults ----------
  static Group createDefaultGroup() {
    return Group(
      id: 'default_id',
      name: 'Default Group Name',
      ownerId: 'default_owner_id',
      userRoles: const {},
      userIds: const [],
      createdTime: DateTime.now(),
      description: 'Default Description',
      invitedUsers: const {},
    );
  }

  @override
  String toString() {
    return 'Group{id: $id, name: $name, ownerId: $ownerId, '
        'userRoles: $userRoles, userIds: $userIds, description: $description, '
        'photoUrl: $photoUrl, photoBlobName: $photoBlobName, '
        'computedPhotoUrl: $computedPhotoUrl, invitedUsers: $invitedUsers, '
        'defaultCalendarId: $defaultCalendarId, defaultCalendar: $defaultCalendar}';
  }
}

extension GroupCalendarX on Group {
  /// Primary way to get the calendar id for this group.
  String? get calendarId =>
      (defaultCalendarId != null && defaultCalendarId!.isNotEmpty)
          ? defaultCalendarId
          : defaultCalendar?.id;

  bool get hasCalendar => calendarId != null;
}
